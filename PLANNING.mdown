- config macro to remove the prefix
- test steps that can be run at test cases’ discretion
- multiple setUp/tearDown blocks per suite
- differential-prototypal suite inheritance?
- composable contexts (inheriting setUp/tearDown/stateClass/steps from parent context)?
- algebra/visitor protocol for test suites & cases
- code coverage generation
	- how would this work? lexically? not sure I like this idea much at all.
- documentation generation
	- thinking this would use a visitor over tests to generate docs for them
- running in an app should run only that app’s tests, not L3’s own as well, by default
- the runner needs some idea of scope for tests
	- such that we can say “only this suite,” “only this case,” or more interesting patterns—“only suites matching this regexp with cases matching that one” or “only suites defined in this bundle”
	- maybe like paths: bundle/suite/suite/case. main/**/foo would run any case named “foo” in any suite defined in the main bundle (this sounds a little like xpath)
	- how do we tell what Mach-O binary a given test suite/case came from? if we can figure that out we can compare it against -[NSBundle mainBundle], I think
- ui to show test results in test builds
- ui to run test suites and show their results in debug builds
- some way to send test results to another process (maybe running on a different machine)
- test that release builds really don’t have the test methods, classes, etc compiled in (dead code stripped)
- count assertion successes/failures in the formatter and add them to the strings
- time test cases and suites in the formatter and add them to the strings
- integrate with Xcode
	- it should run L3 as part of the test scheme!
	- it should show our test results among the logs and highlight failed assertions in the editor
	- just like OCUnit, only better
- asynchronous tests
- test context should include the queue
- some way for test suites to indicate that they need to be run on the main queue
- some way for test suites to indicate that they can be concurrent (I am thinking of this as dispatch_async to a private concurrent dispatch_queue_t where “normal” test invocations are dispatch_barrier_async)
- mess around with multiple suites per file; does it make any sense? is it useful?
	- declaring common test steps in a suite in another file sounds more useful
- can tests be defined in headers? is that sensible at all?
- how do preconditions, postconditions, and invariants work? predicates which are matched before/after/both for invocations of a given method? how? dynamic subclass + override during tests? (that sounds like a lot of fun.)
- what are the remaining obstacles to using L3 to test in “real” projects?
	- Xcode integration
	- some assurance that it does not affect release builds
- exception handling
- patterns to match exceptions?
- test the assertion patterns
- output warning lines for test cases without any assertions
- split formatting out from test result building
- multiplexer algebra which sends events to each of its child algebras
	- use that to send events to both the formatter and the test result builder
- optionally break into the debugger on assertion failure? or just have people add a breakpoint on assertion failures?
- formatters should watch test results and not events
- move string cardinalizing/pluralizing into a category or class